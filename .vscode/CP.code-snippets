{
  "CP Skeleton": {
    "prefix": "cp-skeleton",
    "scope": "cpp",
    "body": [
      "#define NEED_CORE",
      "#define NEED_IO",
      "",
      "#include \"templates/Base.hpp\"",
      "",
      "void solve() {",
      "\t$0",
      "}",
      "",
      "auto main() -> int {",
      "\tINT(T);",
      "\tFOR(T) solve();",
      "\treturn 0;",
      "}"
    ],
    "description": "Full C++ competitive programming skeleton with template includes and main loop"
  },
  "CP Main": {
    "prefix": "cp-main",
    "scope": "cpp",
    "body": [
      "auto main() -> int {",
      "\tINT(T);",
      "\tFOR(T) solve();",
      "\treturn 0;",
      "}"
    ],
    "description": "Main function with test case loop"
  },
  "CP Solve": {
    "prefix": "cp-solve",
    "scope": "cpp",
    "body": [
      "void solve() {",
      "\t$0",
      "}"
    ],
    "description": "Solve function template"
  },
  "CP INT": {
    "prefix": "cp-int",
    "scope": "cpp",
    "body": [
      "INT($1);$0"
    ],
    "description": "Read 32-bit integer(s) from input"
  },
  "CP LL": {
    "prefix": "cp-ll",
    "scope": "cpp",
    "body": [
      "LL($1);$0"
    ],
    "description": "Read 64-bit integer(s) from input"
  },
  "CP STR": {
    "prefix": "cp-str",
    "scope": "cpp",
    "body": [
      "STR($1);$0"
    ],
    "description": "Read string(s) from input"
  },
  "CP VEC": {
    "prefix": "cp-vec",
    "scope": "cpp",
    "body": [
      "VEC($1, $2, $3);$0"
    ],
    "description": "Read vector: VEC(type, name, size)"
  },
  "CP OUT": {
    "prefix": "cp-out",
    "scope": "cpp",
    "body": [
      "OUT($1);$0"
    ],
    "description": "Write output with newline"
  },
  "CP FOR": {
    "prefix": "cp-for",
    "scope": "cpp",
    "body": [
      "FOR($1, $2) {",
      "\t$0",
      "}"
    ],
    "description": "Forward loop: FOR(var, bound)"
  },
  "CP FOR_R": {
    "prefix": "cp-forr",
    "scope": "cpp",
    "body": [
      "FOR_R($1, $2) {",
      "\t$0",
      "}"
    ],
    "description": "Reverse loop: FOR_R(var, bound)"
  },
  "CP VV": {
    "prefix": "cp-vv",
    "scope": "cpp",
    "body": [
      "vv($1, $2, $3, $4, $5);$0"
    ],
    "description": "2D vector: vv(type, name, rows, cols, init)"
  },
  "CP Fix": {
    "prefix": "cp-fix",
    "scope": "cpp",
    "body": [
      "auto $1 = fix([&](auto self, $2) -> $3 {",
      "\t$0",
      "});"
    ],
    "description": "Y-combinator recursive lambda: fix(name, params, return_type)"
  },
  "CP Debug": {
    "prefix": "cp-debug",
    "scope": "cpp",
    "body": [
      "debug($1);$0"
    ],
    "description": "Debug output macro"
  },
  "CP DSU": {
    "prefix": "cp-dsu",
    "scope": "cpp",
    "body": [
      "struct DSU {",
      "  Vec<I32> parent, rank, size;",
      "  I32 components;",
      "",
      "  DSU(I32 n) : parent(n), rank(n, 0), size(n, 1), components(n) {",
      "    std::iota(all(parent), 0);",
      "  }",
      "",
      "  I32 find(I32 x) {",
      "    if (parent[x] != x) parent[x] = find(parent[x]);",
      "    return parent[x];",
      "  }",
      "",
      "  bool unite(I32 x, I32 y) {",
      "    x = find(x);",
      "    y = find(y);",
      "    if (x == y) return false;",
      "    if (rank[x] < rank[y]) std::swap(x, y);",
      "    parent[y] = x;",
      "    size[x] += size[y];",
      "    if (rank[x] == rank[y]) rank[x]++;",
      "    components--;",
      "    return true;",
      "  }",
      "",
      "  bool connected(I32 x, I32 y) { return find(x) == find(y); }",
      "  I32 component_size(I32 x) { return size[find(x)]; }",
      "  I32 num_components() const { return components; }",
      "};",
      "$0"
    ],
    "description": "Disjoint Set Union (Union-Find) with path compression and union by rank"
  },
  "CP SegmentTree": {
    "prefix": "cp-segtree",
    "scope": "cpp",
    "body": [
      "template <typename T, typename F = std::plus<T>>",
      "struct SegmentTree {",
      "  I32 n;",
      "  Vec<T> tree;",
      "  F op;",
      "  T identity;",
      "",
      "  SegmentTree(I32 size, T id = T{}, F func = F{})",
      "    : n(1), op(func), identity(id) {",
      "    while (n < size) n *= 2;",
      "    tree.assign(2 * n, identity);",
      "  }",
      "",
      "  SegmentTree(const Vec<T>& v, T id = T{}, F func = F{})",
      "    : SegmentTree(sz(v), id, func) {",
      "    FOR(i, sz(v)) tree[n + i] = v[i];",
      "    FOR_R(i, 1, n) tree[i] = op(tree[2*i], tree[2*i + 1]);",
      "  }",
      "",
      "  void update(I32 pos, T val) {",
      "    pos += n;",
      "    tree[pos] = val;",
      "    while (pos > 1) {",
      "      tree[pos >> 1] = op(tree[pos], tree[pos ^ 1]);",
      "      pos >>= 1;",
      "    }",
      "  }",
      "",
      "  T query(I32 l, I32 r) {  // [l, r)",
      "    T res_left = identity, res_right = identity;",
      "    l += n; r += n;",
      "    while (l < r) {",
      "      if (l & 1) res_left = op(res_left, tree[l++]);",
      "      if (r & 1) res_right = op(tree[--r], res_right);",
      "      l >>= 1; r >>= 1;",
      "    }",
      "    return op(res_left, res_right);",
      "  }",
      "",
      "  T get(I32 pos) { return tree[n + pos]; }",
      "};",
      "$0"
    ],
    "description": "Iterative segment tree with custom monoid (default: sum). query(l,r) is half-open [l,r)"
  },
  "CP FenwickTree": {
    "prefix": "cp-fenwick",
    "scope": "cpp",
    "body": [
      "template <typename T>",
      "struct FenwickTree {",
      "  I32 n;",
      "  Vec<T> tree;",
      "",
      "  FenwickTree(I32 size) : n(size), tree(size + 1, T{}) {}",
      "",
      "  void add(I32 idx, T val) {",
      "    idx++;  // 1-indexed internally.",
      "    while (idx <= n) {",
      "      tree[idx] += val;",
      "      idx += idx & -idx;",
      "    }",
      "  }",
      "",
      "  T sum(I32 idx) {  // Sum [0, idx].",
      "    idx++;",
      "    T res{};",
      "    while (idx > 0) {",
      "      res += tree[idx];",
      "      idx -= idx & -idx;",
      "    }",
      "    return res;",
      "  }",
      "",
      "  T range_sum(I32 l, I32 r) {  // Sum [l, r].",
      "    return sum(r) - (l > 0 ? sum(l - 1) : T{});",
      "  }",
      "",
      "  I32 lower_bound(T val) {",
      "    if (val <= T{}) return 0;",
      "    I32 pos = 0;",
      "    I32 pw = 1;",
      "    while (pw <= n) pw *= 2;",
      "    pw /= 2;",
      "    while (pw > 0) {",
      "      I32 next = pos + pw;",
      "      if (next <= n && tree[next] < val) {",
      "        val -= tree[next];",
      "        pos = next;",
      "      }",
      "      pw /= 2;",
      "    }",
      "    return pos;",
      "  }",
      "};",
      "$0"
    ],
    "description": "Fenwick Tree (BIT): point add, prefix sum, range sum, lower_bound. 0-indexed interface."
  },
  "CP Sieve": {
    "prefix": "cp-sieve",
    "scope": "cpp",
    "body": [
      "struct Sieve {",
      "  I32 n;",
      "  Vec<bool> is_prime;",
      "  Vec<I32> primes;",
      "  Vec<I32> smallest_factor;",
      "",
      "  Sieve(I32 size) : n(size), is_prime(size + 1, true), smallest_factor(size + 1) {",
      "    is_prime[0] = is_prime[1] = false;",
      "    FOR(i, 2, n + 1) {",
      "      if (is_prime[i]) {",
      "        primes.pb(i);",
      "        smallest_factor[i] = i;",
      "        for (I64 j = (I64)i * i; j <= n; j += i) {",
      "          is_prime[j] = false;",
      "          if (smallest_factor[j] == 0) smallest_factor[j] = i;",
      "        }",
      "      }",
      "    }",
      "  }",
      "",
      "  bool check_prime(I32 x) const {",
      "    return x >= 2 && x <= n && is_prime[x];",
      "  }",
      "",
      "  Vec<PII> factorize(I32 x) const {",
      "    Vec<PII> factors;",
      "    if (x <= 1) return factors;",
      "    if (x > n) {",
      "      for (I32 p = 2; (I64)p * p <= x; ++p) {",
      "        if (x % p != 0) continue;",
      "        I32 cnt = 0;",
      "        while (x % p == 0) { x /= p; cnt++; }",
      "        factors.pb({p, cnt});",
      "      }",
      "      if (x > 1) factors.pb({x, 1});",
      "      return factors;",
      "    }",
      "    while (x > 1) {",
      "      I32 p = smallest_factor[x];",
      "      I32 cnt = 0;",
      "      while (x % p == 0) { x /= p; cnt++; }",
      "      factors.pb({p, cnt});",
      "    }",
      "    return factors;",
      "  }",
      "",
      "  I32 count_divisors(I32 x) const {",
      "    auto factors = factorize(x);",
      "    I32 result = 1;",
      "    for (auto [p, cnt] : factors) result *= (cnt + 1);",
      "    return result;",
      "  }",
      "};",
      "$0"
    ],
    "description": "Linear sieve: primality, prime list, smallest_factor table, factorize, count_divisors"
  },
  "CP Trie": {
    "prefix": "cp-trie",
    "scope": "cpp",
    "body": [
      "struct Trie {",
      "  struct Node {",
      "    std::unordered_map<char, I32> children;",
      "    bool is_end = false;",
      "    I32 count = 0;         // Number of words ending at this node.",
      "    I32 prefix_count = 0;  // Number of words with this prefix.",
      "  };",
      "",
      "  Vec<Node> nodes;",
      "",
      "  Trie() { nodes.eb(); }  // Root node.",
      "",
      "  void insert(const std::string& word) {",
      "    I32 current = 0;",
      "    for (char c : word) {",
      "      nodes[current].prefix_count++;",
      "      if (!nodes[current].children.count(c)) {",
      "        nodes[current].children[c] = sz(nodes);",
      "        nodes.eb();",
      "      }",
      "      current = nodes[current].children[c];",
      "    }",
      "    nodes[current].prefix_count++;",
      "    nodes[current].is_end = true;",
      "    nodes[current].count++;",
      "  }",
      "",
      "  bool search(const std::string& word) {",
      "    I32 current = 0;",
      "    for (char c : word) {",
      "      if (!nodes[current].children.count(c)) return false;",
      "      current = nodes[current].children[c];",
      "    }",
      "    return nodes[current].is_end;",
      "  }",
      "",
      "  I32 count_prefix(const std::string& prefix) {",
      "    I32 current = 0;",
      "    for (char c : prefix) {",
      "      if (!nodes[current].children.count(c)) return 0;",
      "      current = nodes[current].children[c];",
      "    }",
      "    return nodes[current].prefix_count;",
      "  }",
      "",
      "  Vec<std::string> find_with_prefix(const std::string& prefix) {",
      "    Vec<std::string> result;",
      "    I32 current = 0;",
      "    for (char c : prefix) {",
      "      if (!nodes[current].children.count(c)) return result;",
      "      current = nodes[current].children[c];",
      "    }",
      "    std::function<void(I32, std::string)> dfs = [&](I32 node, std::string word) {",
      "      if (nodes[node].is_end) {",
      "        FOR(nodes[node].count) result.pb(word);",
      "      }",
      "      for (auto [c, child] : nodes[node].children) dfs(child, word + c);",
      "    };",
      "    dfs(current, prefix);",
      "    return result;",
      "  }",
      "};",
      "$0"
    ],
    "description": "Trie with multiplicity: insert, search, count_prefix, find_with_prefix"
  },
  "CP Z-Algorithm": {
    "prefix": "cp-z-algo",
    "scope": "cpp",
    "body": [
      "inline Vec<I32> z_algorithm(const std::string& s) {",
      "  I32 n = sz(s);",
      "  Vec<I32> z(n);",
      "  if (n == 0) return z;",
      "  z[0] = n;",
      "  I32 l = 0, r = 0;",
      "  FOR(i, 1, n) {",
      "    if (i <= r) z[i] = _min(static_cast<I32>(r - i + 1), z[i - l]);",
      "    while (i + z[i] < n && s[z[i]] == s[i + z[i]]) z[i]++;",
      "    if (i + z[i] - 1 > r) { l = i; r = i + z[i] - 1; }",
      "  }",
      "  return z;",
      "}",
      "$0"
    ],
    "description": "Z-algorithm: z[i] = length of longest substring starting at i matching a prefix of s"
  },
  "CP KMP": {
    "prefix": "cp-kmp",
    "scope": "cpp",
    "body": [
      "struct KMP {",
      "  std::string pattern;",
      "  Vec<I32> failure;",
      "",
      "  KMP(const std::string& p) : pattern(p) {",
      "    I32 m = sz(pattern);",
      "    failure.assign(m, 0);",
      "    FOR(i, 1, m) {",
      "      I32 j = failure[i - 1];",
      "      while (j > 0 && pattern[i] != pattern[j]) j = failure[j - 1];",
      "      if (pattern[i] == pattern[j]) j++;",
      "      failure[i] = j;",
      "    }",
      "  }",
      "",
      "  Vec<I32> search(const std::string& text) {",
      "    Vec<I32> matches;",
      "    I32 n = sz(text), m = sz(pattern);",
      "    if (m == 0) {",
      "      matches.resize(n + 1);",
      "      std::iota(all(matches), 0);",
      "      return matches;",
      "    }",
      "    I32 j = 0;",
      "    FOR(i, n) {",
      "      while (j > 0 && text[i] != pattern[j]) j = failure[j - 1];",
      "      if (text[i] == pattern[j]) j++;",
      "      if (j == m) { matches.pb(i - m + 1); j = failure[j - 1]; }",
      "    }",
      "    return matches;",
      "  }",
      "};",
      "$0"
    ],
    "description": "KMP pattern matching: O(n+m) preprocessing and search. Returns start indices of all matches."
  },
  "CP ExtGCD": {
    "prefix": "cp-extgcd",
    "scope": "cpp",
    "body": [
      "template <typename T>",
      "std::tuple<T, T, T> extended_gcd(T a, T b) {",
      "  if (b == 0) return {a, 1, 0};",
      "  auto [g, x1, y1] = extended_gcd(b, a % b);",
      "  T x = y1;",
      "  T y = x1 - (a / b) * y1;",
      "  return {g, x, y};",
      "}",
      "",
      "template <typename T>",
      "T mod_inverse(T a, T m) {",
      "  auto [g, x, _] = extended_gcd(a, m);",
      "  if (g != 1) return -1;  // No inverse exists.",
      "  return ((x % m) + m) % m;",
      "}",
      "$0"
    ],
    "description": "Extended GCD returning (gcd, x, y) s.t. ax+by=gcd. Bundled with mod_inverse."
  },
  "CP Point2D": {
    "prefix": "cp-point2d",
    "scope": "cpp",
    "body": [
      "template <typename T = F64>",
      "struct Point2D {",
      "  T x, y;",
      "",
      "  Point2D(T x = 0, T y = 0) : x(x), y(y) {}",
      "",
      "  Point2D operator+(const Point2D& p) const { return Point2D(x + p.x, y + p.y); }",
      "  Point2D operator-(const Point2D& p) const { return Point2D(x - p.x, y - p.y); }",
      "  Point2D operator*(T k) const { return Point2D(x * k, y * k); }",
      "  Point2D operator/(T k) const { return Point2D(x / k, y / k); }",
      "",
      "  T dot(const Point2D& p) const { return x * p.x + y * p.y; }",
      "  T cross(const Point2D& p) const { return x * p.y - y * p.x; }",
      "  T norm2() const { return x * x + y * y; }",
      "  T norm() const { return sqrt(norm2()); }",
      "",
      "  Point2D rotate(T angle) const {",
      "    T c = cos(angle), s = sin(angle);",
      "    return Point2D(x * c - y * s, x * s + y * c);",
      "  }",
      "",
      "  Point2D perp() const { return Point2D(-y, x); }",
      "",
      "  bool operator<(const Point2D& p) const {",
      "    return x != p.x ? x < p.x : y < p.y;",
      "  }",
      "",
      "  bool operator==(const Point2D& p) const {",
      "    return abs(x - p.x) < EPS && abs(y - p.y) < EPS;",
      "  }",
      "};",
      "",
      "template <typename T>",
      "T orientation(const Point2D<T>& a, const Point2D<T>& b, const Point2D<T>& c) {",
      "  return (b - a).cross(c - a);",
      "}",
      "",
      "template <typename T>",
      "bool on_segment(const Point2D<T>& p, const Point2D<T>& a, const Point2D<T>& b) {",
      "  return abs((b - a).cross(p - a)) < EPS &&",
      "         (p - a).dot(p - b) <= EPS;",
      "}",
      "$0"
    ],
    "description": "2D point with arithmetic, dot/cross product, norm, rotate, perp. Includes orientation() and on_segment() helpers."
  },
  "CP Convex Hull": {
    "prefix": "cp-convex-hull",
    "scope": "cpp",
    "body": [
      "template <typename T>",
      "Vec<Point2D<T>> convex_hull(Vec<Point2D<T>> points) {",
      "  I32 n = sz(points);",
      "  if (n <= 3) return points;",
      "  sort(all(points));",
      "  Vec<Point2D<T>> hull;",
      "  // Lower hull.",
      "  FOR(i, n) {",
      "    while (sz(hull) >= 2 &&",
      "           orientation(hull[sz(hull) - 2], hull.back(), points[i]) <= 0) {",
      "      hull.pop_back();",
      "    }",
      "    hull.pb(points[i]);",
      "  }",
      "  // Upper hull.",
      "  I32 lower_size = sz(hull);",
      "  FOR_R(i, n - 1) {",
      "    while (sz(hull) > lower_size &&",
      "           orientation(hull[sz(hull) - 2], hull.back(), points[i]) <= 0) {",
      "      hull.pop_back();",
      "    }",
      "    hull.pb(points[i]);",
      "  }",
      "  hull.pop_back();  // Remove duplicate point.",
      "  return hull;",
      "}",
      "$0"
    ],
    "description": "Andrew's monotone chain convex hull. Requires Point2D and orientation(). Returns hull in CCW order."
  },
  "CP Rolling Hash": {
    "prefix": "cp-rolling-hash",
    "scope": "cpp",
    "body": [
      "struct RollingHash {",
      "  static constexpr I64 MOD1 = 1e9 + 7;",
      "  static constexpr I64 MOD2 = 1e9 + 9;",
      "  static constexpr I64 BASE1 = 31;",
      "  static constexpr I64 BASE2 = 37;",
      "",
      "  std::string s;",
      "  Vec<I64> hash1, hash2, pow1, pow2;",
      "",
      "  RollingHash(const std::string& str) : s(str) {",
      "    I32 n = sz(s);",
      "    hash1.resize(n + 1); hash2.resize(n + 1);",
      "    pow1.resize(n + 1);  pow2.resize(n + 1);",
      "    pow1[0] = pow2[0] = 1;",
      "    FOR(i, n) {",
      "      hash1[i + 1] = (hash1[i] * BASE1 + s[i]) % MOD1;",
      "      hash2[i + 1] = (hash2[i] * BASE2 + s[i]) % MOD2;",
      "      pow1[i + 1] = (pow1[i] * BASE1) % MOD1;",
      "      pow2[i + 1] = (pow2[i] * BASE2) % MOD2;",
      "    }",
      "  }",
      "",
      "  PLL get_hash(I32 l, I32 r) {",
      "    I64 h1 = (hash1[r] - hash1[l] * pow1[r - l] % MOD1 + MOD1) % MOD1;",
      "    I64 h2 = (hash2[r] - hash2[l] * pow2[r - l] % MOD2 + MOD2) % MOD2;",
      "    return {h1, h2};",
      "  }",
      "",
      "  bool equal(I32 l1, I32 r1, I32 l2, I32 r2) {",
      "    return get_hash(l1, r1) == get_hash(l2, r2);",
      "  }",
      "",
      "  I32 lcp(I32 i, I32 j) {",
      "    I32 left = 0, right = std::min(sz(s) - i, sz(s) - j) + 1;",
      "    while (right - left > 1) {",
      "      I32 mid = (left + right) / 2;",
      "      if (equal(i, i + mid, j, j + mid)) left = mid;",
      "      else right = mid;",
      "    }",
      "    return left;",
      "  }",
      "};",
      "$0"
    ],
    "description": "Double rolling hash (two bases/mods). get_hash(l,r) half-open [l,r). equal(), lcp() in O(1)/O(log n)."
  },
  "CP Miller-Rabin": {
    "prefix": "cp-miller-rabin",
    "scope": "cpp",
    "body": [
      "inline I64 mod_mul64(I64 a, I64 b, I64 mod) {",
      "  return static_cast<I64>((static_cast<__int128>(a) * b) % mod);",
      "}",
      "",
      "inline I64 mod_pow64(I64 base, I64 exp, I64 mod) {",
      "  I64 result = 1 % mod;",
      "  base %= mod;",
      "  while (exp > 0) {",
      "    if (exp & 1) result = mod_mul64(result, base, mod);",
      "    base = mod_mul64(base, base, mod);",
      "    exp >>= 1;",
      "  }",
      "  return result;",
      "}",
      "",
      "inline bool miller_rabin(I64 n) {",
      "  if (n < 2) return false;",
      "  if (n == 2) return true;",
      "  if (n % 2 == 0) return false;",
      "  const Vec<I64> witnesses = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};",
      "  I64 d = n - 1;",
      "  I32 r = 0;",
      "  while (d % 2 == 0) { d /= 2; r++; }",
      "  auto check_witness = [&](I64 a) {",
      "    I64 x = mod_pow64(a, d, n);",
      "    if (x == 1 || x == n - 1) return false;",
      "    FOR(_, r - 1) {",
      "      x = mod_mul64(x, x, n);",
      "      if (x == n - 1) return false;",
      "    }",
      "    return true;",
      "  };",
      "  for (I64 a : witnesses) {",
      "    if (a >= n) break;",
      "    if (check_witness(a)) return false;",
      "  }",
      "  return true;",
      "}",
      "$0"
    ],
    "description": "Deterministic Miller-Rabin primality test for 64-bit integers. Bundled with mod_mul64 and mod_pow64 helpers."
  }
}
